<rule id="security-model" type="critical">
  <meta>
    <title>Security Model</title>
    <version>1.1</version>
    <scope>files:*.tsx,*.jsx,*.ts,*.js,*.yml,next.config.*</scope>
  </meta>
  
  <encryption-at-rest>
    <notes>AES via CryptoJS; Password never in repo; Stored in data/encrypted_notes.dat</notes>
    <images>Include in encrypted ZIP; No unencrypted images in repo; Convert to data URLs during decryption</images>
  </encryption-at-rest>
  
  <authentication>
    <passwords>No plaintext; Client-side validation; Validation via successful decryption; Dedicated login page</passwords>
    <sessions>Password in sessionStorage; No tokens needed; Expires when browser closes; AuthGuard for app-wide protection; URL referrer preservation</sessions>
  </authentication>
  
  <client-side>
    <decryption>Browser-only; Never send password to server; No server-side password knowledge</decryption>
    <storage>sessionStorage for passwords; Clear on logout; No exposure to external scripts</storage>
  </client-side>
  
  <build-vs-runtime>
    <build>No decryption; No secrets needed; Pass encrypted data to client</build>
    <runtime>Browser-only decryption; Client-side auth; Display after successful auth</runtime>
  </build-vs-runtime>
  
  <security-fails>
    <fail type="critical">Sending password to server</fail>
    <fail type="critical">Storing unencrypted password in localStorage (persistent)</fail>
    <fail type="critical">Decrypting notes at build time</fail>
    <fail type="critical">Storing unencrypted notes in the repository</fail>
  </security-fails>
  
  <examples>
    <correct-password-handling>
      <![CDATA[
      // Correct: Store password in sessionStorage
      export function storePassword(password: string): void {
        sessionStorage.setItem('daily_lofs_password', password);
      }

      // Correct: Simple authentication check
      export function isAuthenticated(): boolean {
        if (typeof window === 'undefined') return false;
        return getStoredPassword() !== null;
      }

      // Correct: Client-side decryption with redirect
      try {
        const decryptedData = await decryptNotes(encryptedData, password);
        if (decryptedData) {
          storePassword(password);
          router.push(referrer || '/');
        }
      } catch (error) {
        console.error('Error:', error);
      }
      ]]>
    </correct-password-handling>
    <incorrect-practices>
      <![CDATA[
      // WRONG: Sending password to server
      fetch('/api/validate-password', {
        method: 'POST',
        body: JSON.stringify({ password })
      });

      // WRONG: Storing unencrypted password in localStorage
      localStorage.setItem('user_password', password);

      // WRONG: Decrypting notes at build time
      export async function decryptNotesAtBuild(encryptedData) {
        // This would expose decrypted content at build time
      }
      ]]>
    </incorrect-practices>
  </examples>
  
  <references>
    <ref>CryptoJS:https://cryptojs.gitbook.io/docs/</ref>
    <ref>WebStorage:https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#security</ref>
    <ref>ClientSecurity:https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html</ref>
  </references>
</rule> 